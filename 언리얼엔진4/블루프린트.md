# 블루프린트

### Blueprint  
   - 언리얼 엔진에서 제공하는 프로그램 명령 체계이다.  
   - 게임 플레이에 필요한 요소들을 선으로 연결하는 방식으로 간단하하게 프로그래밍 할 수 있다.  
   - 다른 스크립팅 언어와 같이 객체지향 클래스와 오브젝트를 만드는 데 사용한다.  
   - C++ 클래스를 만들어서 코딩으로 언리얼 엔진 안에서의 모든 컴포넌트를 설정하는것 대신, 비주얼 코딩을 하듯이 Blueprint 클래스로 설정할 수 있음.  
   - 유니티에서 컴포넌트를 드래그앤드롭으로 편리하게 설정하듯이 가능  
     단점: 성능은 C++ 클래스보다 10~20배 차이나게 느리다고 한다.
   - C++ 코딩으로 하던 설정을 한눈에 보면서 할 수 있기 때문에, 직관적이고 처음 언리얼 라이브러리를 익힐 때 많이 도움될듯.  
   → C++ 코드로 클래스에 컴포넌트를 붙이는 과정을 블루프린트에서는 이렇게 간단히 가능  
   *(유니티가 생각나는듯..)*
   - 블루프린트 클래스를 C++ 코드에서 사용하려면 맨 뒤에 _C를 꼭 붙일것.    

### C++ 클래스 파일을 재사용해 Blueprint 만들기
   - 이미 만들어 놓은 C++ 클래스로 만들면 된다.  
   - C++ 소스코드에 있던 모든 내용들이 블루프린트에 그대로 설정되어 있다!  
   - 경우에 따라서 간단하게 블루프린트 클래스를 활용하면 스크립트에 있는 모든 정보를 편하게 볼 수 있고, 다른 메시나 머터리얼을 바꾸기도 쉽다.  

### 에디터
1. 뷰포트
2. 컨스트럭션 스크립트: 블루프린트의 커스터마이징 가능한 파라미터나 프리팹을 설정하는 공간. 일부 값을 수정할 때, 스크립트를 직접 수정하지 않고 일부 값만 변경해도 수정이 가능하게 한다. 게임이 실행되기 전에 컴포넌트 값들을 변경시켜 둘 수 있다.
3. 이벤트 그래프: 게임이 실행되고 있을 때 작동하는 스크립트를 작성하는 공간

### Construction Script 와 Event Graph 차이점  
둘 다 블루프린트 스크립트로 작성할 수 있는 것은 똑같다.  

1. Construction Script: 게임 시작 전에 미리 오브젝트의 초기값을 설정하고 싶을 때 사용한다.  
Construction Script로 적용한 내용들은 게임 시작 버튼을 누르기 전에 적용되어 있다. 명확히 알 수 있는 점이 뷰포트에 존재하는 오브젝트들이다. 디테일 창에서 오브젝트의 설정을 변경하면 게임 시작 버튼을 누르지도 않았는데 변경한 내용이 그대로 저장되어 변경된다.

2. Event Graph: 게임을 시작하면 오브젝트가 '이벤트'에 반응하여 동작을 수행하기 위해서 사용한다.   
Event Graph로 적용한 설정들은 게임 시작 버튼을 눌러야 변경된 모습을 볼 수 있다. 디테일 창에서 오브젝트의 설정을 변경하면 Construction Script와는 다르게 게임 시작 버튼을 누르기 전에는 저장된 내용을 확인할 수 없다.



### 에디터에서 다룰 수 있는 블루프린트 종류
1. 레벨 블루프린트: 레벨 단위의 글로벌 이벤트 그래프 역할을 하는 블루프린트, 레벨 내에 있는 특정 액터 인스턴스가 함수 호출이나 흐름 제어 연산 형태로 인력의 동작을 발동시키기 위해 사용  
2. 블루프린트 클래스: 콘텐츠 제작자가 기존의 클래스 위헤 다른 함수성을 쉽게 추가할 수 있도록 해 주는 애셋. 흔히 '블루프린트' 라고 부르는 애셋. 콘텐츠 패키지에 애셋으로 저장됨.  
3. 블루프린트 함수 라이브러리: 다른 블루프린트에서 접근할 수 있는 함수의 모음  
4. 블루프린트 매크로 라이브러리: 다른 블루프린트에서 접근할 수 있는 매크로의 모음  
5. 블루프린트 인터페이스: 다른 블루프린트 간 통신에 사용  
6. 열거형: 흐름 제어를 위해 블루프린트에서 생성 및 사용 가능한 지정 목록  
ex) 캐릭터의 상태: 살아 있음/사망/부상 을 열거형으로  
7. 구조체: 다양한 변수 유형의 모음   
ex) 인벤토리 아이템: 수집한 아이템의 이름/섬네일/메시/수집할 때 음향효과 (각 데이터 유형이 다름)  

### 개발할 때 주로 사용할 블루프린트 유형
1. 레벨 블루프린트  
2. 액터 블루프린트  
3. 애니메이션 블루프린트  
4. 언리얼 모션 그래픽(UMG) UI 용 위젯 블루프린트  

### 블루프린트 사용에 주의할 점
 - 복잡하고 무거운 연산이나 작업을 매 프레임마다 한다면 블루프린트보다 C++ 코드로 작성해야 한다.
 - 블루프린트는 가상머신 위에서 동작하기 때문에, C++가 더 코드상에서 다양한 기능을 제공하고 빠르다.
 - 유효하지 않은 참조(레퍼런스)나 순환 종속성을 피해야 한다.

### 블루프린트 변수 종류
블루프린트 변수는 비슷한 종류별로 색으로 구분되어 보기 편하다.
~~~
1. Boolean: 참/거짓
---
2. Byte: 0~255 의 정수 (unsigned char)
3. Integer: -2,147,483,648 ~ 2,147,483,647 의 정수 (int)
4. Integer64: -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 의 정수 (long)
5. Float: 부동소수점 (float)
---
6. Name: 게임 안에서 식별 가능한 텍스트 조각
7. String: 영숫자로 이루어진 character들의 모음 (string)
8. Text: 유저에게 보여줄 텍스트 (번역된 현지화 텍스트)
---
9. Vector: (X, Y, Z) 3개로 이루어진 데이터 묶음. 3차원 좌표나 RGB 색상 값을 다룰 때 사용한다.
10. Rotator: 3차원 공간에서 회전값을 정의할 때 사용하는 숫자의 묶음
11. Transform: translation, rotation, scale 값을 모두 담고 있는 데이터의 묶음
12. Object: 블루프린트 오브젝트를 담고 있는 데이터의 묶음
~~~

### 자손 블루프린트
부모 블루프린트의 스크립트를 변경하면 자손 블루프린트의 스크립트도 같이 변경된다. 재사용이 가능해 반복되는 작업을 줄일 수 있다.  

### 블루프린트 통신 방법 4가지  
많은 블루프린트들 만들다 보면 서로 정보를 전달하거나 공유해야 하는 경우가 생긴다. 이때 블루프린트 통신이 필요하다.  

**1) 직접 블루프린트 통신**  
가장 흔한 통신 방법이다.  
특정 시점에서 서로 상호작용이 필요한 블루프린트 액터 2개가 있을 때 사용한다. 항상 1:1 즉, 한 블루프린트가 다른 블루프린트로의 접근을 요청한다.  
   1. 공개적으로 노출된(Public) 오브젝트 변수를 만든다.  
   2. 오브젝트 변수를 이용해서 타깃 블루프린트로의 레퍼런스를 구한다.  
   3. 접근하고자 하는 블루프린트의 인스턴스를 지정한다.  
  
<예시>  
블루프린트: 캐릭터 블루프린트, 조명 블루프린트  
목적: 캐릭터가 조명을 껏다킬 수 있게 하기  
 1. 캐릭터 블루프린트 안에서 Public 조명 블루프린트 변수 만들기
 2. 변수 설정값: Editable 체크하기-레벨에 있는 조명 인스턴스를 설정할 수 있게 된다.
 3. 레벨에서 캐릭터 블루프린트를 선택해 보면 조명 변수를 설정할 수 있다.
 4. 처음에 조명 변수는 None로 되어 있다. 레벨에 조명 인스턴스가 여러 개일 수 있기 때문이다.
 5. 조명 변수를 통신할 조명 인스턴스로 설정한다.

이렇게 직접 통신하고자 하는 인스턴스를 설정하고 나면, 설정한 조명 인스턴스와 캐릭터 블루프린트 안에 있는 값들을 접근할 수 있게 된다.


**2) 이벤트 디스패처(Event Dispatcher)**    
이벤트 발생 여부를 리스닝(listen,대기)하는 다른 블루프린트에 알리기 위해 사용한다. 이벤트가 발생하면, 리스닝중이던 블루프린트는 그에 반응하여 서로 통신하며 독립적으로 작업한다.

이벤트 디스패처는 여러개의 이벤트를 바인딩한 구조로 되어 있다. 여러개의 이벤트는 블루프린트 클래스 안에서 바인딩 해도 되지만, 레벨 블루프린트 안에서 이벤트가 발동되도록 할 수 있다.  

입력 값 추가: 이벤트 디스패처에 바인딩된 이벤트들에게 변수를 전송하게 한다. 데이터가 블루프린트 클래스 안에서만 흘러다니는 것이 아니라, 블루프린트 클래스와 레벨 블루프린트를 오가도록 한다.  

이벤트 디스패처에는 이벤트 노드 추가, 노드 바인딩/언바인딩이 가능하다.  

이벤트 노드를 제외하고 각 노드에는 타깃을 설정해줘야 한다:  
1. 블루프린트 클래스: 타깃은 셀프로 자동 설정된다.   
즉 이벤트 리스트가 클래스로 변경되어, 모든 클래스 인스턴스가 변경된다.  
2. 레벨 블루프린트: 레벨 안에 있는 클래스의 인스턴스에 대한 레퍼런스를 타깃으로 설정해줘야한다.   
즉 이벤트 리스트가 해당 클래스 인스턴스에 대해서만으로 변경된다.  

이벤트 바인딩/언바인딩:  
이벤트 디스패처는 바인딩된 이벤트가 없으면 호출을 해도 아무 일이 일어나지 않는다. 여러개의 이벤트(이벤트 리스트)가 이벤트 디스패처에 연결되어 있어야 한다.   
이벤트 바인드는 여러 번 실행해도 한 번만 바인딩된다.  

이벤트 디스패처 호출:  
해당 이벤트 디스패처에 바인딩된 모든 이벤트가 발동되록 호출(Call) 하는 노드를 이용한다. 각각의 이벤트 디스패처에 대해 2개 이상의 Call 노드를 둘 수도 있다.
블루프린트 클래스와 레벨 블루프린트 양쪽에서도 이벤트 디스패처를 호출할 수 있다.  





**3) 블루프린트 인터페이스**  
이름만 있고 구현은 없는 함수 하나 이상으로 된 집합이다. 이를 다른 블루프린트에 추가할 수 있다. 블루프린트에 인터페이스를 추가하면 추가한 블루프린트는 인터페이스에 들어있던 함수를 갖게 된다.
프로그래밍 인터페이스 개념과 같다. 각기 다른 오브젝트가 모두 공통의 인터페이스를 통해 서로 상호작용 할 수 있게 한다.  
블루프린트 인터페이스를 통해 다양한 블루프린트(오브젝트)는 서로간에 데이터를 공유하고 전송할 수 있게 된다.  

  예) 자동차 & 나무 오브젝트 -> 서로 다른 유형의 오브젝트이다.  
그러나 둘 다 무기로 공격하여 부술 수 있다는 1가지 기능을 공유할 수 있다.  
OnTakeWeaponFire 함수를 포함하는 블루프린트 인터페이스를 만든다.  
자동차와 나무 둘 다에 그 블루프린트 인터페이스를 구현하면, 자동차와 나무를 같은 유형으로 간주한다.  
자동차나 나무를 무기로 공격하면 OnTakeWeaponFire 함수를 호출하기만 하면 된다.  

**4) 블루프린트 형변환(Casting)**  
형변환(CastTo)을 사용하면, 형변환을 하려는 오브젝트가 형변환 대상 오브젝트와 같은지 검사해 보는 것이다. 블루프린트에 들어있는 변수, 함수, 이벤트, 기타 커스텀 함수 기능에 접근할 수 있다.   

  예)  
내가 임의로 만든 캐릭터 블루프린트: 변수&커스텀 함수 기능을 가지고 있음.   
이를 디폴트 폰 클래스로 할당한 상황.  
다른 블루프린트에서 플레이어 캐릭터의 프로퍼티에 접근하는 일반적인 방법:  
GetPlayerCharacter를 사용한다.  
**그러나** 커스텀 함수 기능에는 접근할 수 없다.  
**Why?** GetPlayerCharacter는 플레이어 캐릭터를 얻도록 만든 것이지, 특정 유형 캐릭터를 얻도록 구성된 것이 아니기 때문이다.  
- 블루프린트 형변환을 언제 사용하는가?  
  1. 다른 블루프린트의 특수 버전에 접근  
  2. 같은 클래스의 블루프린트 다수에 접근 + 모두 같은 방식으로 변경   
  3. 특정 자손 블루프린트에 접근   

### 블루프린트에서 타깃의 의미?  
타깃: "어떤 액터가 이 멤버 함수를 호출하고 있나요?" 물어보는 것이다.  
멤버 함수: 어떤 오브젝트(블루프린트)에 속해 있는 함수  

함수가 호출되면, 해당 함수는 호출되는 클래스의 인스턴스를 알아야 한다.  

함수가 클래스(= 오브젝트, 블루프린트)에 속해 있을 때, 타깃을 정해서 어떤 클래스의 인스턴스에서 함수를 호출할 지 명확하게 한다.  

### 함수와 커스텀 이벤트의 차이  
함수: 리턴값을 사용할 수 있으며, 로컬 변수를 사용O  
커스텀 이벤트: 리턴값이 없다. 로컬 변수 사용X  



