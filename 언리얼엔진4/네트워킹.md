

<details>
<summary>멀티플레이 서버 모델</summary>
<div markdown="1">

<br>**데디케이티드(Dedicated) 서버 모델:**   
- 게임 클라이언트와 독립적으로 동작하는 서버이다.  
- 하나의 서버가 게임 한판만을 전담한다. 게임의 시작과 함께 서버를 시작하여 해당 게임이 종료되면 서버도 종료된다.  
- 랜선 상에서 소수의 플레이어들끼리 네트워크 플레이를 하기 위해 고안된 형태이다.    
- 플레이어들이 항상 서버를 들어갔다 나갈 수 있다.  
- Windows와 Linux에서 컴파일하고, 가상 서버를 만들 수 있다.  
- 플레이어들은 고정 IP 주소로 접속한다.  
- 눈에 보이는 부분이 없으므로, UI도 필요하지 않는다.  
- 게임 안에서 보이는 실체가 없으므로 Character나 PlayerController도 가지고 있지 않는다.  
- 클라이언트에서 그래픽 기능만을 제거해 서버 역할을 할 수 있도록 수정한 수준이라 클라이언트와 거의 비슷한 CPU, 메모리 사용량을 요구한다.    
- 분산 처리가 용이하다.    
- 소규모 서버 개발이 편리하다.    
예) 오버워치, 배틀그라운드 등 단판 형태의 게임  


**리슨(Listen) 서버 모델:**  
- 리슨 서버는 클라이언트이면서 동시에 서버인 구조이다.  
- 서버는 항상 최소 한개 이상의 클라이언트와 연결되어 있어야 한다.  
- 연결된 클라이언트는 리슨서버에 의해 호출되고, 연결이 끊기면 서버는 동시에 종료된다.  
- 서버는 클라이언트이기도 하기 때문에, 리슨 서버는 UI와 PlayerController를 가지고 있다.  
- 서버는 다른 클라이언트의 IP와 반드시 연결되어 있어야 하기 때문에, 고정 IP 주소를 가지고 있지 않은 인터넷 사용자들에게 문제가 발생한다.  
- OnlineSubsystem 을 사용하여 고정 IP 주소 문제를 해결할 수 있다.  


**클라이언트-서버 모델:**  
- 서버가 모든 클라이언트들의 접속을 받아 서버가 클라이언트간의 통신을 중계한다.  
- 모든 데이터의 송수신이 서버를 경유해서 전달된다.  
- 보안에 유리하다.  
- 전체 송수신 트래픽량이 적다.  
- 일부 연산을 서버 컴퓨터가 감당하므로 클라이언트 컴퓨터의 부담이 줄어든다.  
- 서버를 경유해야 하므로 더 긴 송수신 지연이 발생할 수 있다.  
예) 대규모 동시 다중 접속 게임(MMORPG)  


**피어 투 피어 모델:**  
- 별도의 서버와 클라이언트가 없다.  
- 플레이어 자체가 서버이며 클라이언트가 된다.   
- 각각의 피어는 플레이어 모두에게 신호를 주고 받는다.  
- 적은 수의 플레이어가 대량의 토큰을 주고 받는데 가장 유리하다.  
- 실시간 전략 시뮬레이션이나 격투 액션 게임에 적합하다.  
- 회선의 교환 속도가 빠르다.  
- 서버와 네트워크 거리가 고려되지 않아도 된다.  
예) 스타크래프트, 던전 앤 파이터, 대전 게임  

</div>
</details>
  
  
---
**리플리케이션 (Replication)**  

**신뢰성/비신뢰성 (Reliable/Unreliable)**  
- 리플리케이트된 함수 호출은 신뢰성/비신뢰성 설정이 가능하다.  
- 신뢰성 호출: 반드시 실행이 보장된다.  
- 비신뢰성 호출: 트래픽이 심한 경우 실행되지 않을 수가 있다.  
- 실행되지 않아도 시스템에 문제가 없는 함수들은(예: 시각적 효과) 보통 비신뢰성 설정을 해서 네트워크 포화 상태를 방지한다.  

---

**Boost**  
- C++ 프로그래밍에 사용되는 여러가지 유용한 라이브러리들의 집합.
- 예) 선형대수, 랜덤, 멀티쓰레딩, 영상처리, 정규식, 유닛테스팅, 리플렉션... 등 160가지
- 일부 기능들이 C++ 표준이 될 정도로 검증되었고 우수하다.

**Boost.Asio (Asynchronous Input/Output)**  
- Boost 라이브러리들 중 하나.
- C++로 개발된 네트워크 프로그래밍 라이브러리.
- 다양한 플랫폼(윈도우, 리눅스)에서 호환이 가능한 네트워크 통신이 가능하다.
- 비동기 I/O 프로그래밍을 쉽게 구현할 수 있으며 성능이 우수하다.

---

**마샬링(Marshalling)**
- 객체의 메모리 구조를 저장이나 전송을 위해 적당한 자료형태로 변환하는 것.
- 서로 다른 컴퓨터 혹은 프로그램 간에 데이터가 이동되어야 할 경우에 사용한다.
- 직렬화가 마샬링 과정에 포함된다.  

- [마샬링 과정]
1. 직렬화된 객체를 바이트 단위로 분해한다.
2. 직렬화되어 분해된 데이터를 순서에 따라 전송한다.
3. 전송받은 데이터를 원래대로 복구한다.

**직렬화(Serialization)**
- 객체의 상태를 저장하기 위해서 객체를 Byte stream으로 변환하는 것.
- 객체에 저장된 데이터를 stream에 쓰기 위해서 연속적인 데이터로 변환하는 것.
- 데이터를 파일로 저장할 때 사용한다.
- 메모리 버퍼 또는 네트워크를 통해 데이터를 송수신 할 때 사용한다.

**언리얼 엔진에서의 직렬화**
- 언리얼 오브젝트를 한번에 안전하게 전달하기 위해 사용하는 방법이다.
- FArchive 클래스를 만들어 파일, 메모리 등의 데이터를 전송하는 모든 매체를 관리한다.  
- 데이터를 전송하는 모든 매체는 FArchive 클래스를 상속받아서 구현한다.

---

- 언리얼에서 바이너리 데이터를 표현할 때, 기본적으로 uint8의 동적 배열을 사용한다. 코드에서 uint8, TArray<uint8>로 표현된 데이터 형을 볼 수 있다.
- FVariant와 FArchive는 둘 다 직렬화에 사용한다.  
- FVariant는 데이터를 주고 받기 위해서 사용한다.   
- FArchive는 데이터 저장, 즉 Hard Disk와 주고받기 위해 사용한다.  
  
---

통신 프로그램의 경우 다양한 데이터형의 자료를 주고받는다.
일반적으로 unsigned char 항의 데이터에 담아서 주고받는다.

**Fixed Length Format: 전문을 구성하는 field의 길이가 입력받을 수 있는 최대 사이즈로 고정시키는 방식.**  
  
통신 프로그램에서는 데이터 송수신 형식(Format)을 정해야 한다.  
송수신하는 데이터의 형식: 전문(Fixed Length), XML, JSON  
Fixed Length 형식은 C언어에서 사용하기 가장 편리한 형태다.  
XML, JSON은 parsing을 위한 parser가 필요하다.  
Fixed Length는 parser가 필요하지 않다.  

예) 이름: 최대 32Byte, 주소: 100Byte, 전화번호: 12자리, 주민등록번호: 13자리 등등..  

따라서 C언어로 개발한다면 struct를 이용하여 주고받을 전문을 구성하는 것이 좋다.  

전문의 구성: Header+Body로 구성된다.  

Header:  
- 항상 일정한 크기를 갖는 부분이다.  
- 코드 규칙, 접속자 정보, 오류코드, Body부분의 길이 등등.. 을 포함한다.  
Body:   
- 주고받을 데이터의 형식을 정하는 부분이다.  
- char 형식으로 연속적으로 쭉 이어져 붙어있다.  

---
  
**소켓 전송 시 다루는 자료형**  
C#:   
- 소켓: byte  
- 문자열: Unicode  

C++:   
- 소켓: char   
- 문자열: const char*/ASCII  
- Unicode 사용 시 const char* -> const wchar_t로 바꿀 것  

언리얼: FString-tchar 사용. (UTF8_TO_TCHAR에서 유추)  

