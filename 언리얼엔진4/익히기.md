Character: 걸어다니는 기능이 포함된 폰 유형  
Pawn: 빙의하면 컨트롤러에서 입력을 받을 수 있는 액터  
Actor: 월드에 배치 또는 스폰할 수 있는 오브젝트  
Actor Component: 액터에 추가할 수 있는 재사용 가능 컴포넌트

Player Controller: 플레이어가 사용하는 폰의 제어를 담당하는 특수한 액터, 플레이어의 뇌, 의지와 같은 개념
Game Mode Base: 플레이 중인 게임, 그 규칙, 득점 방식, 그 외 게임 타입의 다른 요소를 정의  
World Settings: 스크립트에서 액세스 가능한 모든 월드 프로퍼티를 담고 있는 액터  

PlayerStart: 게임 내 플레이어가 시작하는 위치. 게임이 시작하면 레벨 내 임의의 위치에 플레이어를 스폰시키는 액터  
PlayerStart가 없다면? 레벨 내에 플레이어 스타트를 추가하지 않고 게임을 플레이하면, 플레이어는 월드의 0,0,0 에서 시작된다. 그 때문에 항상 월드에 플레이어 스타트가 있는지 확인하는 것이 좋다.

---

DirectionalLight

SkyLight

SphereReflectionCapture

AtmosphericFog

BP_Sky_Sphere

---

### Volume: 
  레벨의 특정 영역을 만들고, '그 영역 안에 들어가면' 다양한 효과들을 적용시킬 수 있는 3차원 액터 (ex: 배그 자기장)  

PhysicsVolume: 물리 효과들을 적용시킨다.  
- Physics on Contact: 물리 작용을 시키는 시점을 정할 수 있다.  
  - True: 오브젝트가 볼륨 안에 닿기 시작했을 때 / False: 오브젝트가 볼륨 안에 완전히 들어왔을 때  


PostProcessVolume: 화면 후처리. 연출을 위한 시각 효과들을 적용시킨다.

---

StaticMeshActor: 렌더링 가능한 지오메트리 유형

Tick: 유니티의 Update와 비슷, 액터나 컴포넌트에 일정 간격, 1프레임에 1번 코드조각 또는 블루프린트 스크립트를 실행시킴

BeginPlay: 게임 시작 시~

---
### 이동 관련

**Character 움직이기**
1) AddMovementInput (InputAxis + GetForwardVector)
  - AddMovementInput는 값을 CharacterMovement에 넘겨주면서 Character를 움직이게 한다.  
    그래서 오직 Character 기반 오브젝트에서만 동작했던 것이다.  
    Pawn은 CharacterMovement가 없기 때문에 AddMovementInput을 사용할 수 없다.  


**Pawn 움직이기**
1) AddForce (InputAxis + GetForwardVector)
2) MoveComponentTo (RelativeLocation + MoveDistance + MakeVector)

**Actor 움직이기**
1) SetActorLocation (GetActorLocation + (GetWorldDeltaSeconds * GetForwardVector))

**주의할 점**
1. Character에서만 CharacterMovement 컴포넌트가 붙어 있어서 AddMovementInput 사용이 가능하다.  
=> Pawn, Actor에서는 동작하지 않는다.  
2. 에디터에서 플레이 시 Pawn은 GameModeBase에서 DefaultPawnClass를 조작하고 싶은 오직 1개의 Pawn만 설정할 수 있다. 
3. PlayerController 는 뇌, 의지와 같은 개념이다. 움직이는 실체는 Char/Pawn/Actor.
4. 레벨에 2개 이상의 Pawn을 배치하면 조작할 수 없다. PlayerStart에 의해 자동 생성된 Pawn에서 조작을 시작한다.  


UFloatingPawnMovement  
LaunchCharacter: Character를 대포 발사하듯이 발사한다.  
AddImpulse  

---

ConstructorHelpers::FObjectFinder<USkeletalMesh> SM(TEXT("경로이름'"));

---

SpringArm

SetupAttachment
GetCapsuleComponent

TargetArmLength
SetRelativeRotation

SetRelativeLocationAndRotation
FVector, FRotator

AddControllerYawInput

---

buoyancy: (커스텀 컴포넌트) 부력
  
---
  
Mesh: 비디오 메모리에 캐시되고 그래픽 카드에서 렌더링할 수 있는 폴리곤 세트로 구성되는 3차원 공간을 표현해내는 조각이다.
쉽게 말해, 언리얼 엔진에서 눈에 보이는 3D 물체를 나타내는 것

Static Mesh: 애니메이션 기능을 구현할 수 없는 3D 구조물, 기껏해야 transform으로 스태틱 메시 자체를 움직이는게 전부다.

Skeletal Mesh: 애니메이션 기능을 구현할 수 있는 3D 구조물, 안에 동물처럼 뼈대가 들어가 있다. 이 뼈대들이 연결된 관절들에 의해 애니메이션 기능이 구현 가능하다. 관절이 많을수록 흐물흐물 움직이는게 가능하다. 뼈대마다 움직이게 할 수 있다는 것이다.

---
  
DefaultSceneRoot: 블루프린트를 처음 만들면 항상 있는 이녀석. 레벨 안에서 컴포넌트를 기본 위치에서 오프셋(위치 차이)을 주고 싶을 때 사용한다. 즉, 한 컴포넌트 아래에 있는 모든 것들을 같이 묶어서 움직이고 싶을 때 DefaultSceneRoot를 선택해서 움직이면 된다.  
  
  *컴포넌트를 부모-자식 관계로 만들면?*
  상위 계층 컴포넌트의 위치를 움직이면 함께 움직이게 된다. DefaultSceneRoot 컴포넌트가 최상위 계층임을 생각해 보면 될듯.

---
  
LOD: Levels of Detail

Geometry Brush: 언리얼 레벨 제작에 있어 가장 기본적인 툴, 레벨의 공간 부피를 채워넣거나 파내면서 만든다. 이제는 효율적인 스태틱 메시를 이용해서 주로 레벨 디자인을 한다. 그러나 지오메트리 브러시는 제품 초기 단계에서 레벨과 오브젝트의 빠른 프로토타이핑을 하거나, 3D 모델링 툴 없이 레벨 제작을 할 때 유용하다.  

Timeline node: 블루프린트 내에서 간단한 시간 기반 애니메이션을 빠르게 디자인하고 게임 내 이벤트에 따라 재생되도록 할 수 있는 특수 노드  

DestroyActor: 액터를 파괴시킨다.  

GetActorLocation: 액터의 위치를 반환한다.  

OnActorBeginOverlap: 어떤 액터가 해당 액터에 오버랩되었을 때~  

Overlap(오버랩): 겹치다   
  
---
  
### Simulate Physics:   
  모든 오브젝트들에 Simulate Physics를 적용시키기 위해서는 Collision Mesh가 있어야 한다. 없다면 메시 에디터에서 만들 수 있음.  

MassInKg: 언리얼 엔진에서는 기본적인 질량 값을 오브젝트의 부피를 바탕으로 계산한다.  
Angular & Linear Damping (각형 & 선형 제동): 회전 & 이동에 갖는 저항력을 설정한다.  
Constraints: 원하는 방향으로 힘을 적용시키거나 제한한다.  

Ignore Radial Impulse/Force  
Apply Impulse on Damage  

Start Awake: 게임이 시작할 때는 Simulate Physics는 꺼져 있다가 외부에서 해당 오브젝트에 이벤트가 발생했을 때 부터 Simulate Physics가 적용된다.   

Center of Mass (질량중심): x, y, z offset 값을 설정해 변경할 수 있다.  

### Physics Constraint Actor: 
  물리적 힘 적용시킬 수 있는 액터. 조인트 처럼 2개의 액터를 연결시켜 일정한 제한이나 힘을 가한다.  
  (예시: 그네, 흔들거리는 샹들리에, 물레바퀴, 피직스 바디를 일반적인 영역에 묶어두려는 경우)

Linear/Angular Limits: 선형/각형 힘 제한  
Linear/Angular Motor: 선형/각형 힘 적용  

### Collision:  
가장 효율적인 Collision은 Spherical(구체) Collision 이다. 언리얼 엔진에서는 계산을 위해서 Collision의 반지름을 필요로 하기 때문이다. Capsule Collision은 Spherical Collision을 2개 붙여 놓은 형태로, 가장 흔히 사용된다.  

Simulation Generates Hit Events: 충돌이 발생했을 때 Event Hit를 받아서 스크립트에서 다양하게 활용할 수 있다. (ex: 총알에 맞으면 깨지는 유리창)  
Generate Overlap Events: 두 오브젝트가 겹치면(Overlap) Overlap Event를 받아서 스크립트에서 다양하게 활용할 수 있다. 두 오브젝트가 모두 이 설정이 켜져 있을 때만 이벤트가 발생한다.  
OnActorHit: 다른 오브젝트가 액터의 콜라이더와 부딪혔을 때~  
   
Collision 문제: 가끔 오브젝트가 너무 빠르게 움직이면 충돌 시 뚫고 지나간다.   
해결1) CCD(Continuous Colision Detection)을 적용시킨다.   
해결2) 서브스테핑(Substepping)을 적용시킨다.   
두 방법 다 성능하락 문제가 있다는 점을 고려해야 한다.  

  
