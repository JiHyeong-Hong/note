Character: 걸어다니는 기능이 포함된 폰 유형  
Pawn: 빙의하면 컨트롤러에서 입력을 받을 수 있는 액터  
Actor: 월드에 배치 또는 스폰할 수 있는 오브젝트  
Actor Component: 액터에 추가할 수 있는 재사용 가능 컴포넌트

Player Controller: 플레이어가 사용하는 폰의 제어를 담당하는 특수한 액터, 플레이어의 뇌, 의지와 같은 개념
Game Mode Base: 플레이 중인 게임, 그 규칙, 득점 방식, 그 외 게임 타입의 다른 요소를 정의  
World Settings: 스크립트에서 액세스 가능한 모든 월드 프로퍼티를 담고 있는 액터  

PlayerStart: 게임 내 플레이어가 시작하는 위치. 게임이 시작하면 레벨 내 임의의 위치에 플레이어를 스폰시키는 액터  
PlayerStart가 없다면? 레벨 내에 플레이어 스타트를 추가하지 않고 게임을 플레이하면, 플레이어는 월드의 0,0,0 에서 시작된다. 그 때문에 항상 월드에 플레이어 스타트가 있는지 확인하는 것이 좋다.

---

DirectionalLight

SkyLight

SphereReflectionCapture

AtmosphericFog

BP_Sky_Sphere

---

Volume: 레벨의 특정 영역을 만들고, '그 영역 안에 들어가면' 다양한 효과들을 적용시킬 수 있는 3차원 액터. (ex: 배그 자기장)

PhysicsVolume: 물리 효과들을 적용시킨다.

PostProcessVolume: 화면 후처리. 연출을 위한 시각 효과들을 적용시킨다.

---

StaticMeshActor: 렌더링 가능한 지오메트리 유형

Tick: 유니티의 Update와 비슷, 액터나 컴포넌트에 일정 간격, 1프레임에 1번 코드조각 또는 블루프린트 스크립트를 실행시킴

BeginPlay: 게임 시작 시~

---
### 이동 관련

**Character 움직이기**
1) AddMovementInput (InputAxis + GetForwardVector)
  - AddMovementInput는 값을 CharacterMovement에 넘겨주면서 Character를 움직이게 한다.  
    그래서 오직 Character 기반 오브젝트에서만 동작했던 것이다.  
    Pawn은 CharacterMovement가 없기 때문에 AddMovementInput을 사용할 수 없다.  


**Pawn 움직이기**
1) AddForce (InputAxis + GetForwardVector)
2) MoveComponentTo (RelativeLocation + MoveDistance + MakeVector)

**Actor 움직이기**
1) SetActorLocation (GetActorLocation + (GetWorldDeltaSeconds * GetForwardVector))

**주의할 점**
1. Character에서만 CharacterMovement 컴포넌트가 붙어 있어서 AddMovementInput 사용이 가능하다.  
=> Pawn, Actor에서는 동작하지 않는다.  
2. 에디터에서 플레이 시 Pawn은 GameModeBase에서 DefaultPawnClass를 조작하고 싶은 오직 1개의 Pawn만 설정할 수 있다. 
3. PlayerController 는 뇌, 의지와 같은 개념이다. 움직이는 실체는 Char/Pawn/Actor.
4. 레벨에 2개 이상의 Pawn을 배치하면 조작할 수 없다. PlayerStart에 의해 자동 생성된 Pawn에서 조작을 시작한다.  


UFloatingPawnMovement

---

ConstructorHelpers::FObjectFinder<USkeletalMesh> SM(TEXT("경로이름'"));

---

SpringArm

SetupAttachment
GetCapsuleComponent

TargetArmLength
SetRelativeRotation

SetRelativeLocationAndRotation
FVector, FRotator

AddControllerYawInput

---

buoyancy: (커스텀 컴포넌트) 부력
  
---
  
Mesh: 비디오 메모리에 캐시되고 그래픽 카드에서 렌더링할 수 있는 폴리곤 세트로 구성되는 3차원 공간을 표현해내는 조각이다.
쉽게 말해, 언리얼 엔진에서 눈에 보이는 3D 물체를 나타내는 것

Static Mesh: 애니메이션 기능을 구현할 수 없는 3D 구조물, 기껏해야 transform으로 스태틱 메시 자체를 움직이는게 전부다.

Skeletal Mesh: 애니메이션 기능을 구현할 수 있는 3D 구조물, 안에 동물처럼 뼈대가 들어가 있다. 이 뼈대들이 연결된 관절들에 의해 애니메이션 기능이 구현 가능하다. 관절이 많을수록 흐물흐물 움직이는게 가능하다. 뼈대마다 움직이게 할 수 있다는 것이다.

---
  
DefaultSceneRoot: 블루프린트를 처음 만들면 항상 있는 이녀석. 레벨 안에서 컴포넌트를 기본 위치에서 오프셋(위치 차이)을 주고 싶을 때 사용한다. 즉, 한 컴포넌트 아래에 있는 모든 것들을 같이 묶어서 움직이고 싶을 때 DefaultSceneRoot를 선택해서 움직이면 된다.  
  
  *컴포넌트를 부모-자식 관계로 만들면?*
  상위 계층 컴포넌트의 위치를 움직이면 함께 움직이게 된다. DefaultSceneRoot 컴포넌트가 최상위 계층임을 생각해 보면 될듯.

---
  
LOD: Levels of Detail

Geometry Brush: 언리얼 레벨 제작에 있어 가장 기본적인 툴, 레벨의 공간 부피를 채워넣거나 파내면서 만든다. 이제는 효율적인 스태틱 메시를 이용해서 주로 레벨 디자인을 한다. 그러나 지오메트리 브러시는 제품 초기 단계에서 레벨과 오브젝트의 빠른 프로토타이핑을 하거나, 3D 모델링 툴 없이 레벨 제작을 할 때 유용하다.  

Timeline node: 블루프린트 내에서 간단한 시간 기반 애니메이션을 빠르게 디자인하고 게임 내 이벤트에 따라 재생되도록 할 수 있는 특수 노드  

DestroyActor: 액터를 파괴시킨다.  

GetActorLocation: 액터의 위치를 반환한다.  

OnActorBeginOverlap: 어떤 액터가 해당 액터에 오버랩되었을 때~  

Overlap(오버랩): 겹치다   
