# 최적화

3D 에셋: 
- LODs
- HLODs

광원(Lighting): 
- 광원 복잡도
- 동적 광원의 수
- 서로 겹치는 광원들은 특히 성능에 영향을 많이 줌

셰이더(Shader): 
- 셰이더(머터리얼) 복잡도
- 아주 커다란 4K 이상의 여러 개 텍스쳐들
- 커다란 데칼 액터들

반사(Reflections): 
- Planar 리플렉션은 특히 성능에 영향을 많이 줌

텍스쳐 스트리밍:
- RVT(Runtime Virtual Texturing)
- SVT(Streaming Virtual Texturing)

물리 시뮬레이션(Physics Simulation)
- CCD(Continuous Collision Detection)는 시뮬레이션의 정확도를 높일 수 있으나, 성능에 영향을 많이 줌

VFX
- 파티클 시스템
- 오버드로우(Overdraw)

Tick 안에서 계속 Move를 진행하면:  
- 1프레임마다 동작하므로 컴퓨터의 성능에 따라서 동작에 차이가 있다.
- 그래서 Delta Seconds를 가져와서 시간에 따라 고정적으로 동작하도록 한다.
- Move 뿐만이 아니라 다양한 동작을 Tick에서 돌게 하면 성능 문제가 있을 수 있으므로, Delta Seconds를 이용하거나 Tick 안에서의 동작을 피하도록 하자.

**비주얼스튜디오에서 솔루션 구성 차이**  
1. 최적화가 덜 되어 있는 대신 디버그 심볼이 많이 있기 때문에 디버그 하기에 편리함  
 - DebugGame: exe 파일을 만들어서 실행함 -> 아트 리소스는 exe 파일에 묶여있지 않아 찾지 못함  
 - DebugGame Editor: 에디터 상에서 돌아가는 dll 파일을 만들어줌  
2. 최적화가 많이 되어서 디버깅 심볼이 적어서 디버그 하기에 불편함   
 - Development: exe 파일을 만들어서 실행함 -> 아트 리소스는 exe 파일에 묶여있지 않아 찾지 못함  
 - Development Editor: 에디터 상에서 돌아가는 dll 파일을 만들어줌  
3. 출시 직전 마지막 빌드 시 사용함  
 - Shipping  
    
**개발에 대한 조언과 알아야 할 점**
1. Derived Data Cache는 파일을 로드할 때 오래 걸리는 요인이므로 한 프로젝트를 여러 PC에서 작업한다면 DDC를 서버에서 공유해서 작업하는 것이 속도가 빠르다.  

2. 프로젝트를 시작한 엔진 버전을 다른 엔진 버전으로 변경하는 것은 권장되지 않는다. 꼭 해야 한다면, 플러그인을 사용하면 수월해진다.

3. 네이밍 컨벤션과 표준을 지켜라. https://github.com/ymkim50/ue4-style-guide/blob/master/README_Kor.md

4. developers 폴더를 사용하면 프로젝트 작업 이후 쿠킹되지 않는다. 작업 중인 것들을 놓기에 좋은 프로토타입 폴더이다.

5. 에셋은 그 출처(경로)를 기억하고 있어야 한다. 모든 팀 멤버가 동일한 경로에서 에셋을 임포트할 수 있도록 동일한 위치에서 에셋을 임포트 해야 한다.

6. 참고로 한 폴더에 있는 메시 머티리얼을 다른 폴더로 옮겼는데도 메시가 계속 해당 머터리얼을 사용한다. 리디렉터가 머터리얼의 새로운 위치가 어디인지 메시에게 알려주기 때문이다.

- **언리얼 엔진의 모듈 구성**  
처음 프로젝트를 만들면 기본적으로 구성되어 있는 모듈: Core, Core UObject, Engine, Input Core  
 => 여기서 개발할 때 필요한 모듈들을 추가해 나간다. 
 
<details>
<summary>비저빌리티 및 오클루전 컬링</summary>
<div markdown="1">
 
일정 시간에 보이는 오브젝트 수를 줄여 성능을 향상시킨다. 레벨의 액터를 화면에 그릴지 말지를 설정하는 식으로 그릴 액터 수를 줄인다.  

- 컬링(Culling, 도태시키다): 렌더링이 필요하지 않은 오브젝트들을 제외시키는 것.  

- 오클루전(Occlusion, 가리다) 컬링: 
다른 오브젝트에 의해 가려진 오브젝트를 추려내서 컬링한다.  
어떤 오브젝트를 가리는 오브젝트의 영역의 해상도가 높아질수록 오버헤드가 커진다.  

1. 디스턴스(Distance)  
액터별로 디테일 LOD Draw 디스턴스 설정을 할 수 있다. 카메라와 해당 액터의 최소/최대 거리에 따라서 액터를 렌더링 여부를 결정한다.  

2. 컬 디스턴스 볼륨
거리와 크기 배열을 사용하여 볼륨 내 액터의 렌더링 여부를 결정한다.   
예) 대규모 야외 레벨에서 건물이나 구조물에 세밀한 실내 장식이 많은데, 멀리서 볼 때 그다지 중요하지 않은 너무 작은 오브젝트를 컬링하고 싶은 경우에 사용한다.  

3. 뷰 프러스텀(Frustum, 절두체) 컬링:  
카메라에 보이는 영역에서 벗어난 오브젝트의 렌더링을 비활성화해 컬링한다.  

4. 프리컴퓨티드 비저빌리티(Precomputed Visibility)  
움직이지 않는 액터의 보이는 상태를 미리 만들어진 그림자 위에 저장해둔다. 라이팅 빌드 단계에서 이 걸링이 진행된다.   
소~중규모 크기의 레벨에서 가장 효율적이다. 저사양 및 모바일 하드웨어에서 많이 사용한다.   

5. 다이나믹 오클루전:  
다양한 컬링 방법들을 선택하여 사용한다. 카메라에 보이는 영역(FOV)에서 다른 액터에 의해 가려져서 액터가 안보이는지를 확인한다.  
GPU와 CPU에게 각 액터들의 보이는 여부를 계속 학습시켜 효율적으로 컬링이 진행될 수 있도록 한다.    

 </div>
 </details>
 
**UI 제작 시 고려할 수 있는 최적화 방법**  

1. 아트 작업은 머티리얼 대신 텍스처 사용하기  
2. 바인딩 또는 틱 이벤트 대신 이벤트를 통한 UI 업데이트 구동 방식을 사용하기  
3. 자주 변경되지 않는 위젯: 인밸리데이션 박스로 위젯을 캐시에 담기  
4. 위젯 리플렉터(Ctrl+Shift+W) 활용: 위젯 관련 정보/통계 모니터링하기  
