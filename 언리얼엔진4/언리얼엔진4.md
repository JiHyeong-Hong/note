# Unreal Engine 4

### 언리얼 엔진의 유니티 엔진의 철학 차이점

### **유니티 ⇒ 빈 깡통에서 컴포넌트를 붙이면서 만들어간다**

 게임에서 만드는 모든 것들이 ‘컴포넌트’ 라는 이름으로 만들어진다. 레고 블록 조립하듯이 게임에 필요한 요소들을 합쳐나가면서 게임을 완성시킨다. 그래서 유연하고 직관적으로 게임을 개발할 수 있다.

 컴포넌트는 그 무엇이든지 될 수 있다. 컴포넌트에 다른 컴포넌트들을 붙일 수도 있고, 유니티에서 지원하는 다양한 기능을 추가하면서 게임에 필요한 요소들을 만든다.

### 언리얼 ⇒ 정해진 상속구조로 되어 있는 오브젝트들을 활용하여 만든 후에 유니티처럼 컴포넌트를 붙이면서 만들어간다

 게임에서 만드는 모든 것들이 미리 정해져 있다. 태생이 정해져 있음. 부모 클래스를 선택하여 게임에 필요한 것들을 미리 정한다. 

Object: 모든 UE4 오브젝트에 대한 직접 베이스 클래스

↓(상속)
Actor: 월드에 배치 또는 스폰할 수 있는 Object

↓(상속)
Pawn: 빙의하면 컨트롤러에서 입력을 받을 수 있는 Actor

↓(상속)
Character: 걸어다니는 기능이 포함된 Pawn

이런 식으로 상속구조.

- **UCLASS()?**  
  - C#, C++20 버전에 있는 reflection 기능이 없어서 UE4에서 직접 만들어준 기능

- **reflection 기능?**
  - 컴파일러가 읽을 수 있는 주석
  - 어떤 클래스가 어떤 특징을 가지고 있다는 정보들을 써두면 → 빌드 툴에서 런타임에 써 놓은 정보들을 추출해서 사용함
  - reflection 기능을 이용해서 언리얼에서 제공하는 다양한 기능을 써 넣는다.
    사용예시) UPROPERTY(VisibleAnywhere)

- **AActor, AMyActor? 앞에 A는 뭐지?**
  - 언리얼 엔진만의 이름 짓기 규칙(Naming Conventions)가 있다.

- **new, delete 사용X**
  - 직접 메모리 관리를 할 필요가 없다. 언리얼 엔진에서 자체적으로 메모리 관리를 해준다. 스마트 포인터를 사용한다.

- **로그 찍기**
  - UE_LOG() 이용해서 로그 찍기 → output log에서 확인 가능 디버깅 할 때 편리함
  - 로그는 파일로 저장되므로 참고 가능

- **게임 모드-월드 세팅**
  - 게임 모드(Game Mode)는 게임에 보이지 않아도 게임의 전반적인 규칙이나 설정 등을 관리하는 클래스이다. 직접 클래스를 만들어서 설정할 수 있다. 언리얼 엔진은 모든 오브젝트들이 게임 개발에 알맞게 이미 다 짜여져 있음을 알 수 있다.

- **Ctrl+N**: 새로운 레벨 만들기

- **세팅-프로젝트-맵&모드-에디터 시작 맵 바꾸기**

- Game Mode -- 게임모드 오버라이드 

- **키설정하기**
  - PlayerInputComponent->BindAxis(TEXT("UpDown"), this, &AMyPawn::UpDown);

- **Paragon 무료 에셋 다운받기**

- **Pawn → Character 클래스**

- **Blueprint**
    - C++ 클래스를 만들어서 코딩으로 언리얼 엔진 안에서의 모든 컴포넌트를 설정하는것 대신, 비주얼 코딩을 하듯이 Blueprint 클래스로 설정할 수 있음.
    - 유니티에서 컴포넌트를 드래그앤드롭으로 편리하게 설정하듯이 가능
     단점: 성능은 C++ 클래스보다 10~20배 차이나게 느리다고 한다.
    - C++ 코딩으로 하던 설정을 한눈에 보면서 할 수 있기 때문에, 직관적이고 처음 언리얼 라이브러리를 익힐 때 많이 도움될듯.
    → C++ 코드로 클래스에 컴포넌트를 붙이는 과정을 블루프린트에서는 이렇게 간단히 가능  
    *(유니티가 생각나는듯..)*
    - 블루프린트 클래스를 C++ 코드에서 사용하려면 맨 뒤에 _C를 꼭 붙일것.
- **MyCharacter.cpp 일부**
    ```cpp
    SpringArm = CreateDefaultSubobject<USpringArmComponent>(TEXT("SPRINGARM"));
    	Camera = CreateDefaultSubobject<UCameraComponent>(TEXT("CAMERA"));
    
    	SpringArm->SetupAttachment(GetCapsuleComponent());
    	Camera->SetupAttachment(SpringArm);
    
    	SpringArm->TargetArmLength = 500.f;
    	SpringArm->SetRelativeRotation(FRotator(-35.f, 0.f, 0.f));
    
    	GetMesh()->SetRelativeLocationAndRotation(
    		FVector(0.f, 0.f, -88.f), FRotator(0.f, -90.f, 0.f));
    
    	static ConstructorHelpers::FObjectFinder<USkeletalMesh> SM(TEXT("SkeletalMesh'/Game/ParagonWraith/Characters/Heroes/Wraith/Meshes/Wraith.Wraith'"));
    ```

![image](https://github.com/JiHyeong-Hong/note/blob/master/images/%EC%96%B8%EB%A6%AC%EC%96%BC%EC%97%94%EC%A7%844/Untitled%201.png)

![image](https://github.com/JiHyeong-Hong/note/blob/master/images/%EC%96%B8%EB%A6%AC%EC%96%BC%EC%97%94%EC%A7%844/Untitled%202.png)

![image](https://github.com/JiHyeong-Hong/note/blob/master/images/%EC%96%B8%EB%A6%AC%EC%96%BC%EC%97%94%EC%A7%844/Untitled.png)

- **Anim Class - AnimInstance(애니메이션 관리)**
에니메이션 코드를 캐릭터 클래스에서 붙이다 보면 관리가 힘듬 → 언리얼 엔진에서는 에니메이션 코드를 별도의 클래스(AnimInstance)를 만들어서 관리하는 것을 제시함
- **MyAniminstance — MyCharacter 사이에서 speed 변수를 어떻게 사용할 것인가?**
1) MyCharacter에 있는 변수 접근 → MyAniminstance에서 접근한 변수를 설정하기
 ⇒ 다른 함수들을 동작시킬 때마다 MyAniminstance를 건드리게 됨
2) MyAniminstance 에 있는 변수 접근 → MyCharacter에서 필요한 것만 꺼내서 주기
 ⇒ 정석적인 방법으로 2번이 많이 쓰임

- Super?
    - MyAniminstancs.h
    
    ```cpp
    UCLASS()
    class FIRSTPROJECT_API UMyAnimInstance : public UAnimInstance
    {
    	GENERATED_BODY()
    
    	// 필요한 정보를 가져오는 함수
    	virtual void NativeUpdateAnimation(float DeltaSeconds) override;
    
    private:
    	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Pawn, Meta=(AllowPrivateAccess=true) )
    	float Speed;
    	
    };
    ```
    
    - MyAniminstance.cpp
    
    ```cpp
    // 필요한 정보를 가져오는 함수
    void UMyAnimInstance::NativeUpdateAnimation(float DeltaSeconds)
    {
    	// super는 공식 C++에서 지원하지 않으나 언리얼엔진에서 지원한다.
      // 헷갈리지 않게 하기 위한 편리한 기능
    	// 원래는 이렇게 해야 맞음 UAnimInstance::NativeUpdateAnimation(DeltaSeconds);
    	Super::NativeUpdateAnimation(DeltaSeconds); 
    
    	auto pawn = TryGetPawnOwner();
    		if (IsValid(pawn))
    		{
    			Speed = pawn->GetVelocity().Size();
    		}
    }
    ```
    ```
