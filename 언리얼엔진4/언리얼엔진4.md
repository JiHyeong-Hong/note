# Unreal Engine 4

### 언리얼 엔진의 유니티 엔진의 철학 차이점

### **유니티 ⇒ 빈 깡통에서 컴포넌트를 붙이면서 만들어간다**

 게임에서 만드는 모든 것들이 ‘컴포넌트’ 라는 이름으로 만들어진다. 레고 블록 조립하듯이 게임에 필요한 요소들을 합쳐나가면서 게임을 완성시킨다. 그래서 유연하고 직관적으로 게임을 개발할 수 있다.

 컴포넌트는 그 무엇이든지 될 수 있다. 컴포넌트에 다른 컴포넌트들을 붙일 수도 있고, 유니티에서 지원하는 다양한 기능을 추가하면서 게임에 필요한 요소들을 만든다.

### 언리얼 ⇒ 정해진 상속구조로 되어 있는 오브젝트들을 활용하여 만든 후에 유니티처럼 컴포넌트를 붙이면서 만들어간다

 게임에서 만드는 모든 것들이 미리 정해져 있다. 태생이 정해져 있음. 부모 클래스를 선택하여 게임에 필요한 것들을 미리 정한다. 

Object: 모든 UE4 오브젝트에 대한 직접 베이스 클래스

↓(상속)
Actor: 월드에 배치 또는 스폰할 수 있는 Object

↓(상속)
Pawn: 빙의하면 컨트롤러에서 입력을 받을 수 있는 Actor

↓(상속)
Character: 걸어다니는 기능이 포함된 Pawn

이런 식으로 상속구조.

- **UCLASS()?**
C#, C++20 버전에 있는 reflection 기능이 없어서 UE4에서 직접 만들어준 기능
- **reflection 기능?**
- 컴파일러가 읽을 수 있는 주석
- 어떤 클래스가 어떤 특징을 가지고 있다는 정보들을 써두면 → 빌드 툴에서 런타임에 써 놓은 정보들을 추출해서 사용함
reflection 기능을 이용해서 언리얼에서 제공하는 다양한 기능을 써 넣는다.
사용예시) UPROPERTY(VisibleAnywhere)
- **AActor, AMyActor? 앞에 A는 뭐지?**
언리얼 엔진만의 이름 짓기 규칙(Naming Conventions)가 있다.
- **new, delete 사용X**
직접 메모리 관리를 할 필요가 없다. 언리얼 엔진에서 자체적으로 메모리 관리를 해준다. 스마트 포인터를 사용한다.
- **로그 찍기**
UE_LOG() 이용해서 로그 찍기 → output log에서 확인 가능 디버깅 할 때 편리함
로그는 파일로 저장되므로 참고 가능