# 개발론

### **언리얼 엔진에서** **게임프로그래밍의 기본 시작 개념**

게임의 모든 것은 Logic(로직)과 Data(데이터)로 나눌 수 있다.  
로직은 게임의 일부분으로 이어지는 명령들과 구조체들의 집합이다. 
데이터는 로직에 사용되고, 게임이 무엇을 할 지 묘사한다.

예를 들어, C++ 코드로 화면에 캐릭터를 그리는 것은 로직 기반이고, 캐릭터가 물리적으로 보이는 모습은 데이터 기반이다. 그런데 실제로 프로젝트가 커지면서 로직/데이터의 구분이 섞이면서 복잡해진다.

⇒ 어떤 기준으로 로직/데이터를 구분하고, 어떤 방법들이 있는지 이해하는 것이 중요하다.

**게임플레이 로직을 구현할 수 있는 방법:**

1. C++ 클래스:
변수들과 함수들을 정의하고 로직을 구현한다.
2. 블루프린트 클래스:
블루프린트의 이벤트 그래프로, 또는 그래프에서 호출하는 함수로 로직을 구현한다.
3. 커스텀 시스템:
머티리얼 에디터, 시퀀서 트랙, AI 비헤이비어 트리처럼 게임플레이 로직을 위한 일정 부분을 구현한다.

**데이터를 구현할 수 있는 방법:**

1. C++ 클래스:
네이티브 클래스 생성자에서 기본값을 설정하고 데이터 상속을 지원한다. 함수 지역 변수에 데이터를 하드코딩할 수도 있지만, 추적하기 어려워 권장하지 않는다.  
2. 구성 파일:
Ini 파일과 콘솔 변수는 C++ 생성자에서 선언한 데이터 오버라이드를 지원하거나 직접 쿼리할 수도 있다.  
3. 블루프린트 클래스:
블루프린트 클래스 디폴트 작동 방식은 C++ 생성자와 비슷하며 데이터 상속을 지원한다. 함수 지역 변수 또는 핀 리터럴 값으로 데이터를 안전하게 설정할 수도 있다.  
4. 데이터 에셋:
인스턴싱할 수 없고 데이터 상속이 필요하지 않은 오브젝트의 경우, 독립형 데이터 에셋이 블루프린트 디폴트보다 사용하기 쉽다.  
5. 테이블:
데이터를 데이터 테이블, 커브 테이블로 가져오거나, 런타임으로 읽을 수 있다.  
6. 인스턴스 배치:
데이터는 레벨 또는 다른 에셋 안에 설정된 블루프린트 또는 C++ 클래스 인스턴스로 저장할 수 있으며, 클래스 디폴트를 오버라이드한다.  
7. 커스텀 시스템: 로직과 마찬가지로 데이터 저장을 위한 커스텀 방식은 많다.  

세이브 게임: 런타임 세이브 게임 파일을 사용하여 위 데이터 유형을 오버라이드 또는 수정할 있다.

예) C++ 클래스에서 파생된 블루프린트 클래스에서 추가한 변수에 접근하는 것은 매우 어려워 권장하지 않는다.
함수와 변수를 정의할 때는, 이들의 접근이 자주 일어나는 기본(base) 레벨에서 정의해야 한다.

로직의 경우 전체 구현을 베이스 레벨에서 하거나, 베이스 레벨에 스텁 함수를 두고 파생 레벨에서 오버라이드 해야한다.

데이터의 경우 조금 복잡하고 시스템이 따라 달라지는데, 가능성이 다양하고 다단계 상속이 흔하기 때문이다. 변수에 대한 기본값은 정의한 그 레벨에서 설정하고, 이후 파생되는 레벨에서 오버라이드해야 한다. 또한 커스텀 규칙에 따라 한 오브젝트에서 다른 오브젝트로 데이터를 복사하여 로직을 작성하는 것이 일반적이다.

⇒ 아무튼.. 위에서 다양한 방법들이 있다고 했지만 결국 대부분 로직을 구현하고 데이터를 저장할 때 C++와 블루프린트 2개를 조합하거나 둘 중 하나를 선택해서 게임을 구현한다.


### (C/C++) .h(헤더파일) 과 .cpp 파일로 소스코드를 분리하는 경우

1. 모든 코드를 한 파일에 작성하면서 코드가 지나치게 길어지는 경우
2. 다른 곳에서 작성한 코드를 재사용할 경우

**소스코드를 분리하는 방법**
- 클래스 선언부는 .h에 작성
- 구현부는 .cpp에 작성  

⇒ 이렇게 분리하여 작성하면, 작성된 클래스를 활용할 경우 #include 시키기만 하면 되기 때문에 편리하다.

### 최적화 - 성능에 영향을 주는 요인들

3D 에셋: 
- LODs
- HLODs

광원(Lighting): 
- 광원 복잡도
- 동적 광원의 수
- 서로 겹치는 광원들은 특히 성능에 영향을 많이 줌

셰이더(Shader): 
- 셰이더(머터리얼) 복잡도
- 아주 커다란 4K 이상의 여러 개 텍스쳐들
- 커다란 데칼 액터들

반사(Reflections): 
- Planar 리플렉션은 특히 성능에 영향을 많이 줌

텍스쳐 스트리밍:
- RVT(Runtime Virtual Texturing)
- SVT(Streaming Virtual Texturing)

물리 시뮬레이션(Physics Simulation)
- CCD(Continuous Collision Detection)는 시뮬레이션의 정확도를 높일 수 있으나, 성능에 영향을 많이 줌

VFX
- 파티클 시스템
- 오버드로우(Overdraw)

Tick 안에서 계속 Move를 진행하면:  
- 1프레임마다 동작하므로 컴퓨터의 성능에 따라서 동작에 차이가 있다.
- 그래서 Delta Seconds를 가져와서 시간에 따라 고정적으로 동작하도록 한다.
- Move 뿐만이 아니라 다양한 동작을 Tick에서 돌게 하면 성능 문제가 있을 수 있으므로, Delta Seconds를 이용하거나 Tick 안에서의 동작을 피하도록 하자.

