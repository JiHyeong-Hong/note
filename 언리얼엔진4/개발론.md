# 개발론

### **언리얼 엔진에서** **게임프로그래밍의 기본 시작 개념**

게임의 모든 것은 Logic(로직)과 Data(데이터)로 나눌 수 있다.  
로직은 게임의 일부분으로 이어지는 명령들과 구조체들의 집합이다. 
데이터는 로직에 사용되고, 게임이 무엇을 할 지 묘사한다.

예를 들어, C++ 코드로 화면에 캐릭터를 그리는 것은 로직 기반이고, 캐릭터가 물리적으로 보이는 모습은 데이터 기반이다. 그런데 실제로 프로젝트가 커지면서 로직/데이터의 구분이 섞이면서 복잡해진다.

⇒ 어떤 기준으로 로직/데이터를 구분하고, 어떤 방법들이 있는지 이해하는 것이 중요하다.

**게임플레이 로직을 구현할 수 있는 방법:**

1. C++ 클래스:
변수들과 함수들을 정의하고 로직을 구현한다.
2. 블루프린트 클래스:
블루프린트의 이벤트 그래프로, 또는 그래프에서 호출하는 함수로 로직을 구현한다.
3. 커스텀 시스템:
머티리얼 에디터, 시퀀서 트랙, AI 비헤이비어 트리처럼 게임플레이 로직을 위한 일정 부분을 구현한다.

**데이터를 구현할 수 있는 방법:**

1. C++ 클래스:
네이티브 클래스 생성자에서 기본값을 설정하고 데이터 상속을 지원한다. 함수 지역 변수에 데이터를 하드코딩할 수도 있지만, 추적하기 어려워 권장하지 않는다.  
2. 구성 파일:
Ini 파일과 콘솔 변수는 C++ 생성자에서 선언한 데이터 오버라이드를 지원하거나 직접 쿼리할 수도 있다.  
3. 블루프린트 클래스:
블루프린트 클래스 디폴트 작동 방식은 C++ 생성자와 비슷하며 데이터 상속을 지원한다. 함수 지역 변수 또는 핀 리터럴 값으로 데이터를 안전하게 설정할 수도 있다.  
4. 데이터 에셋:
인스턴싱할 수 없고 데이터 상속이 필요하지 않은 오브젝트의 경우, 독립형 데이터 에셋이 블루프린트 디폴트보다 사용하기 쉽다.  
5. 테이블:
데이터를 데이터 테이블, 커브 테이블로 가져오거나, 런타임으로 읽을 수 있다.  
6. 인스턴스 배치:
데이터는 레벨 또는 다른 에셋 안에 설정된 블루프린트 또는 C++ 클래스 인스턴스로 저장할 수 있으며, 클래스 디폴트를 오버라이드한다.  
7. 커스텀 시스템: 로직과 마찬가지로 데이터 저장을 위한 커스텀 방식은 많다.  

세이브 게임: 런타임 세이브 게임 파일을 사용하여 위 데이터 유형을 오버라이드 또는 수정할 있다.

예) C++ 클래스에서 파생된 블루프린트 클래스에서 추가한 변수에 접근하는 것은 매우 어려워 권장하지 않는다.
함수와 변수를 정의할 때는, 이들의 접근이 자주 일어나는 기본(base) 레벨에서 정의해야 한다.

로직의 경우 전체 구현을 베이스 레벨에서 하거나, 베이스 레벨에 스텁 함수를 두고 파생 레벨에서 오버라이드 해야한다.

데이터의 경우 조금 복잡하고 시스템이 따라 달라지는데, 가능성이 다양하고 다단계 상속이 흔하기 때문이다. 변수에 대한 기본값은 정의한 그 레벨에서 설정하고, 이후 파생되는 레벨에서 오버라이드해야 한다. 또한 커스텀 규칙에 따라 한 오브젝트에서 다른 오브젝트로 데이터를 복사하여 로직을 작성하는 것이 일반적이다.

⇒ 아무튼.. 위에서 다양한 방법들이 있다고 했지만 결국 대부분 로직을 구현하고 데이터를 저장할 때 C++와 블루프린트 2개를 조합하거나 둘 중 하나를 선택해서 게임을 구현한다.


### (C/C++) .h(헤더파일) 과 .cpp 파일로 소스코드를 분리하는 경우

1. 모든 코드를 한 파일에 작성하면서 코드가 지나치게 길어지는 경우
2. 다른 곳에서 작성한 코드를 재사용할 경우

**소스코드를 분리하는 방법**
- 클래스 선언부는 .h에 작성
- 구현부는 .cpp에 작성  

⇒ 이렇게 분리하여 작성하면, 작성된 클래스를 활용할 경우 #include 시키기만 하면 되기 때문에 편리하다.

### 최적화 - 성능에 영향을 주는 요인들

3D 에셋: 
- LODs
- HLODs

광원(Lighting): 
- 광원 복잡도
- 동적 광원의 수
- 서로 겹치는 광원들은 특히 성능에 영향을 많이 줌

셰이더(Shader): 
- 셰이더(머터리얼) 복잡도
- 아주 커다란 4K 이상의 여러 개 텍스쳐들
- 커다란 데칼 액터들

반사(Reflections): 
- Planar 리플렉션은 특히 성능에 영향을 많이 줌

텍스쳐 스트리밍:
- RVT(Runtime Virtual Texturing)
- SVT(Streaming Virtual Texturing)

물리 시뮬레이션(Physics Simulation)
- CCD(Continuous Collision Detection)는 시뮬레이션의 정확도를 높일 수 있으나, 성능에 영향을 많이 줌

VFX
- 파티클 시스템
- 오버드로우(Overdraw)

Tick 안에서 계속 Move를 진행하면:  
- 1프레임마다 동작하므로 컴퓨터의 성능에 따라서 동작에 차이가 있다.
- 그래서 Delta Seconds를 가져와서 시간에 따라 고정적으로 동작하도록 한다.
- Move 뿐만이 아니라 다양한 동작을 Tick에서 돌게 하면 성능 문제가 있을 수 있으므로, Delta Seconds를 이용하거나 Tick 안에서의 동작을 피하도록 하자.

**비주얼스튜디오에서 솔루션 구성 차이**
    1. 최적화가 덜 되어 있는 대신 디버그 심볼이 많이 있기 때문에 디버그 하기에 편리함  
    DebugGame: exe 파일을 만들어서 실행함 -> 아트 리소스는 exe 파일에 묶여있지 않아 찾지 못함  
    DebugGame Editor: 에디터 상에서 돌아가는 dll 파일을 만들어줌  
    2. 최적화가 많이 되어서 디버깅 심볼이 적어서 디버그 하기에 불편함  
    Development: exe 파일을 만들어서 실행함 -> 아트 리소스는 exe 파일에 묶여있지 않아 찾지 못함  
    Development Editor: 에디터 상에서 돌아가는 dll 파일을 만들어줌  
    3. 출시 직전 마지막 빌드 시 사용함  
    Shipping  
    
**개발에 대한 조언과 알아야 할 점**
1. Derived Data Cache는 파일을 로드할 때 오래 걸리는 요인이므로 한 프로젝트를 여러 PC에서 작업한다면 DDC를 서버에서 공유해서 작업하는 것이 속도가 빠르다.  

2. 프로젝트를 시작한 엔진 버전을 다른 엔진 버전으로 변경하는 것은 권장되지 않는다. 꼭 해야 한다면, 플러그인을 사용하면 수월해진다.

3. 네이밍 컨벤션과 표준을 지켜라. https://github.com/ymkim50/ue4-style-guide/blob/master/README_Kor.md

4. developers 폴더를 사용하면 프로젝트 작업 이후 쿠킹되지 않는다. 작업 중인 것들을 놓기에 좋은 프로토타입 폴더이다.

5. 에셋은 그 출처(경로)를 기억하고 있어야 한다. 모든 팀 멤버가 동일한 경로에서 에셋을 임포트할 수 있도록 동일한 위치에서 에셋을 임포트 해야 한다.

6. 참고로 한 폴더에 있는 메시 머티리얼을 다른 폴더로 옮겼는데도 메시가 계속 해당 머터리얼을 사용한다. 리디렉터가 머터리얼의 새로운 위치가 어디인지 메시에게 알려주기 때문이다.

- **언리얼 엔진의 모듈 구성**  
처음 프로젝트를 만들면 기본적으로 구성되어 있는 모듈: Core, Core UObject, Engine, Input Core  
 => 여기서 개발할 때 필요한 모듈들을 추가해 나간다. 
