# 컴퓨터 일반

**값에 의한 호출 (Call by Value):** 메소드를 호출할 때 인자의 값을 복사해서 전달하는 방식 
→ 메소드에서 변경한 내용이 다른 메소드에 적용되지 않음
= 전달하는 인자 값이 변하지 않음
= 인자를 다루는 메모리 위치가 다름

**참조에 의한 호출 (Call by reference):** 메소드를 호출할 때 인자의 값의 원본을 전달하는 방식 
→ 메소드에서 변경한 내용이 다른 메소드에도 적용됨
= 전달하는 인자 값이 변함
= 인자를 다루는 메모리 위치가 같음
객체는 대부분이 참조에 의한 호출로 생성된다.

**메모리 구조**  
**힙 영역:** 순서 없이 동적으로 할당이 가능한 메모리 저장 공간 (스택에 포인터 → 힙에 데이터 저장), 사용자가 메모리를 관리해야 함  
**스택 영역:** 빠른 접근이 가능한 메모리 영역, 크기가 제한되어 있음, 
함수의 호출, 지역변수, 매개변수가 저장됨

**프로세스:** 프로그램이 실행되어 메모리에 올라가 있는 작업  
(메모리 할당: 코드/데이터/스택/힙)  
**스레드:** 프로세스보다 더 작은 단위의 작업, 같은 프로세스 내 스레드끼리 메모리를 공유한다.  
(메모리 할당: 코드/데이터/힙 + 스택은 스레드 마다 따로)  
⇒ 스레드의 스케줄링은 운영체제가 처리하지 않기 때문에 프로그래머가 직접 동기화 문제에 대응할 수 있어야 한다.

**오버플로우:** 계산 범위를 초과하여 발생하는 오류, 최상위 비트가 부호 저장용 비트일 때 발생

**함수 호출 스택**: { 매개변수 → 반환주소값 → 지역변수 } 순서로 스택에 쌓인다.  

**부동소수점을 컴퓨터에서 표현하는 방식 2가지**  
단정도(Single-precision): 실수를 32bit로 표현한다. 
(부호 1bit + 지수부 8비트 + 가수부 23비트)  
float형을 표현할 때 사용한다.  
배정도(Double-precision): 실수를 64bit로 표현한다. 단정도보다 실수 표현 정밀도가 높다.  
(부호 1bit + 지수부 11bit + 가수부 52bit)  
double형을 표현할 때 사용한다.  

---
인코딩 방식: 한글은 컴퓨터에서 저장되는 방식이 여러개 있다.

ANSI:   
- ASCII 코드를 확장하여 각 나라의 문자를 표현하는 방법이다.  
- 각 나라의 이름을 따서 EUC-KR, EUC-JP 등으로 부른다.  
- 기존에 할당된 ASCII 코드 부분은 그대로 1Byte를 사용한다.  
- 각 나라의 문자 부분은 할당된 2Byte를 사용한다.  
예) 'AB가나': A(1Byte)+B(1Byte)+가(2Byte)+나(2Byte) = 총(6Byte)  
- 문제점: AB가나معنا와 같이 영어+한글+아랍어 문자열을 저장하려고 하면, 기준이 되지 않는 나라의 언어는 깨진다.  
- 해결: 유니코드를 사용한다.  


ASCII(아스키코드):
- 128개의 문자조합을 제공하는 7비트 코드  
- 알파벳, 숫자, 특수기호, 그 외 컴퓨터에 필요한 몇가지만 정의되어 있다.  

Unicode(유니코드): 
- '모든 문자'에 유일한 값을 할당하는 인코딩 방식.  
- 엔디안 인코딩 방식을 알려주기 위한 BOM(Byte Order Mask)을 표시하는 2바이트가 추가로 할당되어 있다.  
- 사용중인 운영체제, 프로그램, 언어에 관계 없이 문자마다 고유한 코드 값을 가지고 있다.  


UCS-2: 
- 모든 문자들을 2Byte로 인코딩한다. 
- BOM
- 모든 UCS-2 방식이 BOM을 달고 있지 않은 형태여서 두 시스템이 서로 다른 엔디안 시스템을 이용한다면 문제가 발생한다.


UTF-8: 모든 문자들을 8비트씩 끊어서 표현    
- 유니코드를 사용하는 인코딩 방식 중 한가지.   
- 영문/숫자/기호는 1Byte    
- 한글/한자는 3Byte    
- 전세계 모든 글자들을 한꺼번에 표현할 수 있다.  
- ASCII코드와 영문과 숫자는 같은 코드로 표현된다.    
- 기존 ASCII부분: 1Byte, 유럽문자: 2Byte, 아시아문자: 3Byte  
- 엔디안 인코딩 문제가 없어 BOM을 반드시 붙일 필요는 없다.  
- 보통은 UTF-8로 저장되었다는 것을 명시적으로 알리기 위해 3Byte의 BOM을 붙인다.  
- 예) A(1Byte)+B(1Byte)+가(3Byte)+나(3Byte) = 총(8Byte)  
- BOM을 붙인 예) BOM(3Byte)+A(1Byte)+B(1Byte)+가(3Byte)+나(3Byte) = 총(11Byte)  


UTF-16: 모든 문자들을 16비트씩 끊어서 표현  
- (거의) 모든 문자가 2Byte로 표현된다.  
- BOM  
- UCS-2 방식의 문제를 해결한다.  
- ASCII 체계와 호환성이 없다.  
- 가변길이가 아니므로(2Byte 고정) 메모리 낭비가 있다.  
- 호환성을 위해 기존의 인코딩 방식들을 모두 변환해서 사용해야 한다.  
예) BOM(2Byte)+A(2Byte)+B(2Byte)+가(2Byte)+나(2Byte) = 총(10Byte)  
