# C# & 객체지향

**Virtual 가상:**  가상 자체로 기능을 함, 구현부가 부분적으로 존재하는 클래스, 상속해서 기능을 추가하는 등 재정의하여 사용  
**abstract 추상:** 구현해야할 클래스의 이름만 있고 구현부가 아예 없음 → 상속받은 클래스에서 구현  
**Interface 인터페이스:** 모두 추상메서드, 설계도 같은 개념,   
멤버 변수 사용X, 다중 상속 가능, 부모-자식 관계 아니어도 사용 가능  

**생성자:** 클래스의 내부에 있는 정보를 원하는 값으로 초기화 하기 위해서 씀  
**오버로딩:** 리턴타입, 메소드이름은 같은데 인자값만 다른 것  
**오버라이딩:** 재정의(덮어쓰기), 자식 클래스에서 다시 만들어서 쓰는 것  

**델리게이트(delegate, 대리자):**  함수포인터, 함수 자체를 인자로 넘겨주는 방법, 대리자가 인자를 대신 받아서 원하는 함수를 실행한다.   
**사장 ↔ 비서 :**
내가 사장님께 연락하고 싶을 때 사장에게 바로 연락하지 않고 비서에게 직접 연락한다.  
(나의 연락처/용건) 전달 : 넘겨준 함수의 인자  
거꾸로 → 연락을 줌 : CallBack
리턴값이 없으면 → System.Action   
리턴값이 있으면 → System.Func   
매개변수가 있으면 Action<”넣을 매개변수”, ...>, 없으면 생략  
사용: 하나의 함수에서 다양한 방식으로 동작하게 하고 싶을 때, 델리게이트 체이닝  

**namespace:** 작은 부분들을 따로 작업하고 같은 프로젝트에 통합하는 경우 프로젝트가 커질수록 클래스 이름이 겹칠 수 있음   
→ 클래스 이름에 접두어로 사용되는 클래스의 집합, 네임스페이스로 클래스를 분류할 수 있다  

**가비지컬렉션(GB):** 동적으로 할당한 메모리 영역 중 필요없게 된 영역을 해제하는 기능  

**박싱:** 값 형식 —> 참조 형식으로 변환하는 과정 예) int/float → object
단순 참조의 20배 오버헤드, 메모리 추가 사용 발생  
**언박싱:** 참조 형식 —> 값 형식으로 변환하는 과정 예) object → int/float  
일반적인 할당의 4배 시간 소요
⇒ 성능 저하를 막으려면, 박싱은 암시적으로 사용되고 있기 때문에 잘 안보여서 주의 깊게 생각하고 사용해야 한다. ex)해시테이블보다는 dictionary. 자료형을 명확하게 설정하기 때문에 속도가 빠르다.

### 객체지향

**다형성:** 하나의 변수 또는 함수가 상황에 따라 다른 의미로 해석되는 것  
**캡슐화:** 변수와 함수를 하나의 단위로 묶는 것, 모듈 간의 결합도를 낮춰서 유지보수성 높임  
**상속:** 부모 클래스의 특성과 기능을 그대로 물려받는 것, 일부 기능은 필요 시 재정의(오버라이딩)  

**객체지향 5원칙 SOLID  
SRP(단일 책임 원칙):** 객체는 오직 하나의 변경의 이유만을 가져야 한다, 예) 계산기 프로그램 사칙연산 클래스에 GUI출력 코드를 넣지 않는다  
**OCP(개방-폐쇄 원칙):** 재정의, 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다 예) 스타크래프트 유닛의 이동 메서드, 브루들링은 특이할 때  
**LSP(리스코프 치환 원칙):** 상속원칙, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 잘 작동해야 한다, 예) 마우스의 다양한 종류  
**ISP(인터페이스 분리 원칙):** 클라이언트에서 사용하지 않는 메서드는 사용해선 안된다, 인터페이스를 목적에 맞게 분리한다, 예) 충돌 처리, 이펙트 처리, 서버측과 클라측에서 서로 쓸모없는 인터페이스를 제공하지 않게 하기  
**DIP(의존성 역전 원칙):** 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준의 클래스에 의존해서는 안 된다  


### 디자인 패턴
**싱글톤(Singleton):** 어떤 클래스가 최초 1번만 메모리를 할당하고(static) 그 메모리에 인스턴스를 만들어 사용한다.
장점: 메모리 낭비 방지, 전역 클래스이므로 데이터 공유하기 쉽다.
단점: 너무 커지면 데이터를 공유시킬 때 결합도가 높아져 유지보수/수정 어려워진다.
