# 자료구조

(노션에서 보기: https://watery-bedbug-3a4.notion.site/e37afd6a3f6f42f3b67b92dd2539bff5)

### DFS (Depth First Search, 깊이 우선 탐색)

- 자료를 탐색할 때 깊이를 우선적으로 하여 탐색하는 알고리즘
- 전체 노드를 맹목적으로 탐색하고자 할 때 사용
- 빠르게 모든 경우의 수를 탐색하고자 할 때 사용
- 스택을 사용해 구현 (구현이 간단함)
- 순환호출을 사용해서도 구현
- O(N)
- 알고리즘
    1. 탐색 시작 노드를 스택에 넣기 → 방문 처리
    2. 스택에 넣은(최상단) 노드가+
    가장 가까이 붙어있는(인접한) 노드 중에서+
    방문하지 않은 노드+
    하나라도 있다면? → 이 노드를 스택에 넣기 → 방문 처리
    3. 스택의 넣은(최상단) 노드가+
    가장 가까이 붙어있는(인접한) 노드 중에서+
    방문하지 않은 노드+
    없으면? → 스택에서 최상단 노드 꺼내기
    4. 2~3번의 과정을 더 이상 수행할 수 없을 때까지 반복

![Untitled](https://github.com/JiHyeong-Hong/note/blob/master/images/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/Untitled.png)


### BFS (Breadth First Search, 너비 우선 탐색)

- 자료를 탐색할 때 너비를 우선적으로 하여 탐색하는 알고리즘
- 전체 노드를 맹목적으로 탐색하고자 할 때 사용
- 고급 그래프 탐색 알고리즘에서 자주 활용
- 큐를 사용해 구현 (구현이 간단함)
- O(N)
- DFS보다 수행 시간 좋음
- 알고리즘
    1. 탐색 시작 노드를 큐에 넣기 → 방문 처리
    2. 큐에서 노드를 꺼내 해당 노드의 
    가장 가까이 붙어있는(인접한) 노드+
    방문하지 않은 노드들 모두 큐에 넣기 → 방문처리
    3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복

![Untitled](https://github.com/JiHyeong-Hong/note/blob/master/images/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/Untitled%201.png)

### 배열

- 같은 자료형을 여러개 담을 수 있는 자료 구조
- Array:  Element(요소)Element(요소)Element(요소)Element(요소)...
- 반복문-배열 활용도 높음
- 배열의 크기가 정해지면 다시 바꿀 수 없음, 요소 변경은 가능
- char[ ] vs string
- 장점: 특정 요소에 직접 접근 가능
- 단점: 데이터가 들어갈 공간을 미리 메모리에 할당해야 함

### 연결 리스트

- 배열의 불편한 점을 해결한 자료구조
- 원하는 위치로의 삽입이나 삭제가 비효율적인 배열
- 구조체+포인터 함께 사용
- 중간 지점에 노드 추가/삭제 가능
- 유연한 메모리 공간 할당

### 스택

- 가장 먼저 쌓인 데이터는 가장 나중에 꺼내고, 가장 맨 위에 있는 데이터를 먼저 꺼내는 자료구조
- Last In - First Out 구조 (후입 선출)
- 배열 or 연결리스트로 구현 가능
- 연결리스트로 구현하면 필요한 메모리 만큼만 구현이 가능
- pop(), push(), peek(), isEmpty()

### 큐

- 먼저 들어간 데이터가 먼저 나오는 자료구조
- First In - First Out (선입선출)
- 배열 or 연결리스트로 구현 가능

### 트리

- 나무의 형태를 뒤집은 것과 같은 형태의 자료구조
- 길이(length): 출발 노드에서 목적지 노드까지 거쳐야 하는 가짓수
- 깊이(depth): 루트 노드에서 특정 노드까지의 길이

### 이진트리

- 최대 2개의 자식만을 가질 수 있는 트리
- 포인터를 이용하여 구현하면 효과적
- 이진 트리의 순회
    - 전위순회(Preorder): 자기 자신 출력 → 왼쪽 자식 방문 → 오른쪽 자식 방문 순서로 순회
    - 중위순회(Inorder): 왼쪽 자식 방문 → 자기 자신 출력 → 오른쪽 자식 방문
    - 후위순회(Postorder): 왼쪽 자식 방문 → 오른쪽 자식 방문 → 자기 자신 출력
- 포화 이진 트리(Full Binary Tree): 리프 노드를 제외한 모든 노드가 두 자식을 가지고 있는 트리
- 완전 이진 트리(Complete Binary Tree): 모든 노드들이 왼쪽 자식부터 차근차근 채워진 노드
- 높이 균형 트리(Height Balanced Tree): 왼쪽 자식 트리와 오른쪽 자식 트리의 높이가 1 이상 차이 나지 않는 트리 → 이렇게 만들어야 자료구조에서 활용하기 좋음
